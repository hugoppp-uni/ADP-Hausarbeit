\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{hyphenat}
\usepackage{pdfpages}
\usepackage{placeins}
\usepackage{subfig}
\usepackage{hyperref}
\usepackage{listings}

\title{Algorithmen und Datenstrukturen Hausarbeit:\\Vergleich von Bäumen}
\author{Hugo Protsch - 2510833}
\usepackage[a4paper, total={6in, 8in}]{geometry}

\begin{document}

    \maketitle
    \tableofcontents
    \newpage
    \section*{Einleitung}\label{sec:Einleitung}
    \addcontentsline{toc}{section}{Einleitung}

    In der ersten Praktikumsaufgabe haben wir binäre Suchbäume betrachtet.
    Wir haben festgestellt, dass diese im Vergleich zu verketteten Listen eine erheblich
    bessere Laufzeit aufweisen, da beim Traversieren des Baumes nur über die
    Höhe des Baumes gelaufen wird, statt, wie bei der Liste, über jedes Element.

    Es fiel jedoch auf, dass der Vorteil beim Einfügen von aufsteigenden und
    absteigenden Zahlen verloren geht.
    Hierbei entsteht ein Baum, der entartet, also nicht balanciert, ist.
    Im Extremfall entsteht somit eine einfach verkettete Liste.
    Die Laufzeit von Einfüge-, Lösch- und Suchoperationen
    ist in diesem Fall wieder linear.
    Um eine solche Entartung der Bäume und die daraus resultierende verminderte Performance
    zu vermeiden, muss also eine Strategie entwickeln werden, die den Baum balanciert hält.
    Ein Ansatz, der in Abschnitt~\ref{sec:avl-tree} betrachtet wird, ist der AVL-Baum,
    der jeweils beim Einfügen und Löschen von Elementen die
    Balance des Baumes überprüft und im Falle der Entartung diese sofort ausgleicht.

    Eine zweite Variation des binären Suchbaumes, die in Abschnitt~\ref{sec:splay-tree}
    betrachtet wird, ist der Splay-Tree.
    Dieser hat das Ziel, Elemente, die häufig zugegriffen werden, im Baum möglichst weit oben zu
    halten und somit die Zugriffszeit auf diese zu verringern.
    Anders als beim AVL-Baum, wird ein Splay-Tree nicht balanciert, somit kann der Baum, wie ein
    normaler Binärbaum, entarten.
    Der Vorteil liegt also lediglich beim wiederholten Zugriff auf eine kleine Teilmenge der im
    Baum befindlichen Elementen.

    In beiden Abschnitten wird zunächst der Algorithmus beschrieben, anschließend der Entwurf zur
    Implementation vorgestellt.
    Außerdem in Abschnitt~\ref{sec:laufzeitmessung} eine Laufzeitmessung durchgeführt, und mithilfe einer
    Trendlinie die Komplexität bestimmt.
    Des Weiteren werden die beiden Algorithmen miteinander und mit einem normalen Binärbaum
    verglichen.


    \section{AVL Tree}\label{sec:avl-tree}
    \input{latexChapters/avl.tex}

    \FloatBarrier
    \newpage

    \section{Splay Tree}\label{sec:splay-tree}
    \input{latexChapters/splay.tex}

    \FloatBarrier
    \newpage

    \section{Laufzeitmessung}\label{sec:laufzeitmessung}
    \input{latexChapters/laufzeitmessung.tex}

    \FloatBarrier
    \newpage
    \appendix

    \section{Bildquellenverzeichnis}\label{sec:bildquellen}

    \paragraph{Abbildung~\ref{fig:rebalancing}}\mbox{}\\

    Basierend auf Grundlage von:\\
    \url{https://commons.wikimedia.org/wiki/File:AVL_Tree_Rebalancing_he.svg}

    \paragraph{Abbildung~\ref{fig:splayingCase-zig}}\mbox{}\\

    \url{https://en.wikipedia .org/wiki/File:Splay_tree_zig .svg}

    \paragraph{Abbildung~\ref{fig:splayingCase-zig-zag}}\mbox{}\\

    \url{https://en.wikipedia.org/wiki/File:Zigzag.gif}

    \paragraph{Abbildung~\ref{fig:splayingCase-zig-zig}}\mbox{}\\

    \url{https://en.wikipedia.org/wiki/File:Zigzig.gif}

    \includepdf[pages=1,pagecommand=\section{Eigenständigkeitserklärung}]{img/eigenst}

\end{document}
